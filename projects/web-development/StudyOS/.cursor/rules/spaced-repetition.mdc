---
alwaysApply: true
---
# Spaced Repetition System Implementation

This document details the spaced repetition algorithm implementation in StudyOS, based on learning science research and the Leitner system.

## Learning Science Background

### Spaced Repetition Principles
- **Forgetting Curve**: Memory retention decreases exponentially over time without reinforcement
- **Spacing Effect**: Information is better retained when study sessions are spaced out over time
- **Testing Effect**: Active recall (testing) is more effective than passive review
- **Desirable Difficulties**: Optimal learning occurs when material is challenging but not overwhelming

### Leitner System
StudyOS implements a modified Leitner system with 5 boxes:
- **Box 1**: New cards, reviewed daily
- **Box 2**: Cards reviewed every 3 days
- **Box 3**: Cards reviewed weekly (7 days)
- **Box 4**: Cards reviewed bi-weekly (14 days)
- **Box 5**: Cards reviewed monthly (30 days)

## Database Schema for Spaced Repetition

```prisma
model Card {
  id            Int         @id @default(autoincrement())
  question      String
  answer        String
  deckId        Int
  deck          Deck        @relation(fields: [deckId], references: [id], onDelete: Cascade)
  
  // Spaced repetition fields
  box           Int         @default(1)        // Current Leitner box (1-5)
  intervalDays  Int         @default(1)        // Days until next review
  nextDue       DateTime    @default(now())    // When card is next due for review
  easeFactor    Float       @default(2.5)      // SuperMemo ease factor (optional)
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  reviewLogs    ReviewLog[]
}

model ReviewLog {
  id         Int      @id @default(autoincrement())
  cardId     Int
  card       Card     @relation(fields: [cardId], references: [id], onDelete: Cascade)
  userId     Int
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Review outcome
  status     String   // "again", "hard", "good", "easy"
  reviewedAt DateTime @default(now())
  
  // Context information
  responseTime  Int?    // Response time in milliseconds
  note         String? // Optional notes about the review
}
```

## Algorithm Implementation

### Review Response Mapping
```typescript
enum ReviewResponse {
  AGAIN = "again",  // Incorrect, move to box 1
  HARD = "hard",    // Correct but difficult, smaller interval increase
  GOOD = "good",    // Correct, normal interval increase
  EASY = "easy"     // Correct and easy, larger interval increase
}

const BOX_INTERVALS = [1, 3, 7, 14, 30]; // Days for each box

interface ReviewResult {
  newBox: number;
  newInterval: number;
  nextDue: Date;
}
```

### Core Algorithm Functions

```typescript
export function calculateNextReview(
  currentBox: number,
  response: ReviewResponse,
  currentInterval: number
): ReviewResult {
  let newBox = currentBox;
  let newInterval = currentInterval;

  switch (response) {
    case ReviewResponse.AGAIN:
      // Move back to box 1, review tomorrow
      newBox = 1;
      newInterval = BOX_INTERVALS[0];
      break;

    case ReviewResponse.HARD:
      // Stay in same box or move back one, shorter interval
      newBox = Math.max(1, currentBox - 1);
      newInterval = BOX_INTERVALS[newBox - 1];
      break;

    case ReviewResponse.GOOD:
      // Move to next box (if not already at max)
      newBox = Math.min(5, currentBox + 1);
      newInterval = BOX_INTERVALS[newBox - 1];
      break;

    case ReviewResponse.EASY:
      // Move up two boxes or to max, longer interval
      newBox = Math.min(5, currentBox + 2);
      newInterval = BOX_INTERVALS[newBox - 1] * 1.3; // 30% bonus
      break;
  }

  const nextDue = new Date();
  nextDue.setDate(nextDue.getDate() + newInterval);

  return {
    newBox,
    newInterval: Math.round(newInterval),
    nextDue
  };
}

export function getCardsForReview(cards: Card[]): Card[] {
  const now = new Date();
  return cards.filter(card => new Date(card.nextDue) <= now);
}

export function prioritizeReviewCards(cards: Card[]): Card[] {
  return cards.sort((a, b) => {
    // Prioritize by due date (oldest first)
    const dueDateDiff = new Date(a.nextDue).getTime() - new Date(b.nextDue).getTime();
    if (dueDateDiff !== 0) return dueDateDiff;
    
    // Then by box (lower boxes first)
    return a.box - b.box;
  });
}
```

### Server Operation Implementation

```typescript
// src/server/operations/flashcards.ts
import type { ReviewCard } from 'wasp/server/operations';
import { calculateNextReview, ReviewResponse } from '../utils/spacedRepetition';

export const reviewCard: ReviewCard = async (args, context) => {
  if (!context.user) {
    throw new HttpError(401, 'Authentication required');
  }

  const { cardId, response, responseTime } = args;
  
  // Get current card
  const card = await context.entities.Card.findUnique({
    where: { id: cardId },
    include: { deck: true }
  });

  if (!card || card.deck.userId !== context.user.id) {
    throw new HttpError(404, 'Card not found');
  }

  // Calculate next review
  const reviewResult = calculateNextReview(
    card.box,
    response as ReviewResponse,
    card.intervalDays
  );

  // Update card
  const updatedCard = await context.entities.Card.update({
    where: { id: cardId },
    data: {
      box: reviewResult.newBox,
      intervalDays: reviewResult.newInterval,
      nextDue: reviewResult.nextDue
    }
  });

  // Log the review
  await context.entities.ReviewLog.create({
    data: {
      cardId,
      userId: context.user.id,
      status: response,
      responseTime,
      reviewedAt: new Date()
    }
  });

  return updatedCard;
};
```

## Study Session Management

### Session Planning
```typescript
export function planStudySession(
  availableCards: Card[],
  targetDuration: number, // minutes
  newCardLimit: number = 20
): Card[] {
  const reviewCards = getCardsForReview(availableCards);
  const newCards = availableCards
    .filter(card => card.box === 1 && new Date(card.nextDue) > new Date())
    .slice(0, newCardLimit);

  // Prioritize review cards, then add new cards
  const sessionCards = [
    ...prioritizeReviewCards(reviewCards),
    ...newCards
  ];

  // Estimate session length (assume 30 seconds per card)
  const estimatedCards = Math.floor((targetDuration * 60) / 30);
  
  return sessionCards.slice(0, estimatedCards);
}
```

### Progress Tracking
```typescript
export function calculateStudyStats(reviewLogs: ReviewLog[]): StudyStats {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const todayLogs = reviewLogs.filter(
    log => new Date(log.reviewedAt) >= today
  );

  const correctToday = todayLogs.filter(
    log => ['good', 'easy'].includes(log.status)
  ).length;

  const totalToday = todayLogs.length;
  const accuracyToday = totalToday > 0 ? (correctToday / totalToday) * 100 : 0;

  return {
    cardsReviewedToday: totalToday,
    accuracyToday: Math.round(accuracyToday),
    streak: calculateStreak(reviewLogs),
    totalCards: reviewLogs.length
  };
}
```

## User Interface Considerations

### Review Interface Design
- **Clear Question Display**: Large, readable text
- **Answer Reveal**: Click to show answer
- **Response Buttons**: Color-coded difficulty buttons
- **Progress Indicator**: Show session progress
- **Keyboard Shortcuts**: 1=Again, 2=Hard, 3=Good, 4=Easy

### Visual Feedback
- **Box Progression**: Show which box a card is in
- **Next Review Date**: Display when card will be seen again
- **Study Streak**: Motivational streak counter
- **Daily Goal**: Progress toward daily review target

### Accessibility
- **Keyboard Navigation**: Full keyboard support
- **Screen Reader Support**: Proper ARIA labels
- **High Contrast**: Ensure sufficient color contrast
- **Font Sizing**: Adjustable text size

## Performance Optimizations

### Database Queries
```typescript
// Efficient query for due cards
const dueCards = await context.entities.Card.findMany({
  where: {
    deck: { userId: context.user.id },
    nextDue: { lte: new Date() }
  },
  include: {
    deck: { select: { name: true } }
  },
  orderBy: [
    { nextDue: 'asc' },
    { box: 'asc' }
  ]
});
```

### Caching Strategy
- Cache user's daily review cards
- Preload next session's cards
- Cache study statistics

### Mobile Considerations
- Offline review capability
- Sync when connection restored
- Touch-friendly interface
- Swipe gestures for responses

## Research-Based Enhancements

### Future Improvements
1. **Adaptive Intervals**: Adjust intervals based on individual performance
2. **Difficulty Analysis**: Identify consistently difficult cards
3. **Optimal Timing**: Suggest best review times based on circadian rhythms
4. **Interference Reduction**: Space similar cards to reduce confusion
5. **Metacognitive Training**: Help users assess their own knowledge

### A/B Testing Opportunities
- Different interval schedules
- Button layouts and colors
- Progress visualization methods
- Gamification elements